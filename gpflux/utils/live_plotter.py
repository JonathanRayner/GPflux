# Copyright (C) PROWLER.io 2020 - All Rights Reserved
# Unauthorized copying of this file, via any medium is strictly prohibited
# Proprietary and confidential

from contextlib import contextmanager
from functools import wraps
import inspect
from pathlib import Path
from time import time
from typing import Callable, Optional, TypeVar, Any, Dict

import numpy as np
from matplotlib import pyplot as plt
from matplotlib.animation import FFMpegFileWriter

from gpflux.exceptions import InvalidPlotFunctionError

__all__ = [
    "live_plot",
]


def live_plot(*args, **kwargs):
    """This is a decorator to turn function that operates on figures (and/or axes) into
    a live plotting function.

    It is a thin wrapper around the LivePlotter class (which is also a decorator), and
    has been used because it allows the decorator to be called both with and without
    arguments.
    """
    if len(args) == 1 and callable(args[0]) and kwargs == {}:
        return LivePlotter()(*args, **kwargs)  # usage: @live_plot
    else:
        return LivePlotter(*args, **kwargs)  # usage: @live_plot(do_animation=True)


class LivePlotter:
    """Class decorator a function that operates on figures (and/or axes) into a live plotting
    function.
    """

    def __init__(
        self,
        fig_kwargs: Optional[Dict] = None,
        subplots_kwargs: Optional[Dict] = None,
        do_animation: bool = False,
        animation_dir: Optional[str] = "animations",
        animation_kwargs: Optional[Dict] = None,
    ):
        """
        :params fig_kwargs: Keywords to be passed to figure constructor
        :params subplots_kwargs: Keywords to be passed to subplots constructor
        :params do_animation: Whether to record the liveplot as an animation
        :params animation_dir: Directory to save animation (relative to user)
        :params animation_kwargs: Keywords to be passed to the animation file writer constructor
        """
        self.fig_kwargs = fig_kwargs if fig_kwargs else {}
        self.subplots_kwargs = subplots_kwargs if subplots_kwargs else {}
        self.animation_kwargs = animation_kwargs if animation_kwargs else {"fps": 10}

        self.do_animation = do_animation
        self.animations_dir = animation_dir
        self.tmp_path = f"{self.animations_dir}/tmp/"

    def __call__(self, func):
        sig = inspect.signature(func)
        if "fig" not in sig.parameters or "axes" not in sig.parameters:
            raise InvalidPlotFunctionError(
                "Wrapped plotting function must take 'fig' and 'axes' as arguments."
            )
        if self.do_animation:
            return self.live_plot(self.animate(func))
        else:
            return self.live_plot(func)

    def live_plot(self, func):
        """
        Decorate a plotting function, that accepts a figure and axes, to create the figure
        and axes and make it live updating.

        This stores the axes and figure on the decorated function itself, to make retrieval easier

        :params func: A callable which optionally takes a matplotlib figure and axes
        :returns: the decorated function, that now saves a updates an autogenerated figure
            when called
        """

        fig_attrname = "_%s_liveplot_fig" % id(func)
        axes_attrname = "_%s_liveplot_ax" % id(func)

        @wraps(func)
        def decorated(*args, fig=None, axes=None, **kwargs):
            try:
                stored_fig = getattr(func, fig_attrname)
                stored_axes = getattr(func, axes_attrname)
                for sax in stored_axes:
                    sax.clear()

                fig = stored_fig
                axes = stored_axes

            except AttributeError:
                if fig is None:
                    fig = plt.figure(**self.fig_kwargs)
                if axes is None:
                    if self.subplots_kwargs != {}:
                        axes = fig.subplots(**self.subplots_kwargs)
                    else:
                        axes = np.array([fig.add_subplot(111)])

                plt.ion()
                plt.show()

                setattr(func, fig_attrname, fig)
                setattr(func, axes_attrname, axes)

            ret = func(*args, fig=fig, axes=axes, **kwargs)

            plt.pause(0.001)
            return ret

        if not hasattr(decorated, "save"):
            setattr(decorated, "save", lambda: None)
        return decorated

    def animate(self, func):
        """Takes a live updating plot and saves a snapshot, to be stitched into an
        animation at the end

        :params func: A callable which optionally takes a matplotlib figure and axes
        :returns: the decorated function, that now saves a snapshot everytime it is called

        """
        movie_writer = FFMpegFileWriter(**self.animation_kwargs)
        Path(self.tmp_path).mkdir(parents=True, exist_ok=True)
        file = f"{int(time())}_{id(func)}"
        movie_attrname = f"{self.animations_dir}/{file}"
        tmp_prefix = f"{self.tmp_path}/_{file}"

        @wraps(func)
        def decorated(*args, fig=None, axes=None, **kwargs):
            try:
                getattr(func, movie_attrname)
            except AttributeError:
                movie_writer.setup(
                    fig,
                    outfile=f"{movie_attrname}.mp4",
                    frame_prefix=tmp_prefix,
                    dpi=100,
                )
                setattr(func, movie_attrname, movie_writer)

            ret = func(*args, fig=fig, axes=axes, **kwargs)

            movie_writer.grab_frame()
            return ret

        setattr(decorated, "save", movie_writer.finish)
        return decorated
