# Copyright (C) PROWLER.io 2020 - All Rights Reserved
# Unauthorized copying of this file, via any medium is strictly prohibited
# Proprietary and confidential
from functools import wraps
from contextlib import contextmanager
from pathlib import Path
from time import time
from typing import Callable, Optional, TypeVar, Any, Dict

from matplotlib import pyplot as plt
from matplotlib.animation import FFMpegFileWriter


PlotFuncType = TypeVar(
    "PlotFuncType", bound=Callable[[Optional[plt.Figure], Optional[plt.Axes], ...], Any]
)

class LivePlotter:

    """Class decorator a function that operates on figures (and/or axes) into a live plotting
    function
    """

    def __init__(
        self,
        fig_kwargs: Optional[Dict] = None,
        subplots_kwargs: Optional[Dict] = None,
        do_animation: bool = False,
        animation_kwargs: Optional[Dict] = None,
    ):
        """
        :params fig_kwargs: Keywords to passed to figure constructor
        :params subplots_kwargs: Keywords to be passed to subplots constructor
        :params do_animation: Whether to record the liveplot as an animation
        :params animation_kwargs: Keywords to be passed to the animation file writer constructor
        """
        self.fig_kwargs = fig_kwargs if fig_kwargs else {}
        self.subplots_kwargs = subplots_kwargs if subplots_kwargs else {}
        self.animation_kwargs = animation_kwargs if animation_kwargs else {"fps": 10}

        self.do_animation = do_animation
        self.animations_dir = "animations"
        self.tmp_path = f"{self.animations_dir}/tmp/"

    def __call__(self, func: PlotFuncType) -> PlotFuncType:
        if self.do_animation:
            return self.live_plot(self.animate(func))
        else:
            return self.live_plot(func)

    def live_plot(self, func: PlotFuncType) -> PlotFuncType:
        """
        Decorate a plotting function, that accepts a figure and axes, to create the figure
        and axes and make it live updating.

        This stores the axes and figure on the decorated function itself, to make retrieval easier

        :params func: A callable which optionally takes a matplotlib figure and axes

        :returns: the decorated function, that now saves a updates an autogenerated figure
            when called
        """

        fig_attrname = "_%s_liveplot_fig" % id(func)
        ax_attrname = "_%s_liveplot_ax" % id(func)

        @wraps(func)
        def decorated(fig=None, ax=None, *args, **kwargs):
            try:
                stored_fig = getattr(func, fig_attrname)
                stored_ax = getattr(func, ax_attrname)
                for sax in stored_fig.axes:
                    sax.clear()
                ret = func(stored_fig, stored_ax, *args, **kwargs)
            except AttributeError:
                if fig is None:
                    fig = plt.figure(self.fig_kwargs)
                if ax is None and self.subplots_kwargs:
                    ax = fig.subplots(**self.subplots_kwargs)
                elif ax is None:
                    ax = fig.add_subplot(111)
                ret = func(fig, ax, *args, **kwargs)
                plt.ion()
                plt.show()
                setattr(func, fig_attrname, fig)
                setattr(func, ax_attrname, ax)
            plt.pause(0.001)
            return ret

        return decorated

    def animate(self, func: PlotFuncType) -> PlotFuncType:
        """Takes a live updating plot and saves a snapshot, to be stitched into an
        animation at the end

        :params func: Description

        :returns: the decorated function, that now saves a snapshot everytime it is called

        """
        movie_writer = FFMpegFileWriter(**self.animation_kwargs)
        Path(self.tmp_path).mkdir(parents=True, exist_ok=True)

        file = f"{int(time())}_{id(func)}"
        movie_attrname = f"{self.animations_dir}/{file}"
        tmp_prefix = f"{self.animations_dir}/tmp/_{file}"

        @wraps(func)
        def decorated(fig=None, axes=None, *args, **kwargs):
            try:
                getattr(func, movie_attrname)
                ret = func(fig, axes, *args, **kwargs)
            except AttributeError:
                movie_writer.setup(
                    fig,
                    outfile=f"{movie_attrname}.mp4",
                    frame_prefix=tmp_prefix,
                    dpi=100,
                )
                ret = func(fig, axes, *args, **kwargs)
                setattr(func, movie_attrname, movie_writer)
            movie_writer.grab_frame()
            return ret

        setattr(decorated, "save", movie_writer.finish)
        return decorated

live_plot = LivePlotter()
custom_live_plot = LivePlotter

